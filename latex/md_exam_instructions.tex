The exam consists of a written project followed by an oral discussion. The written project is due to February 16, 2020, at 8\+:55 AM. Orals take place on 16th and 17th of February.


\begin{DoxyItemize}
\item Work in groups made of two/three people.
\item Use a separate git repository.
\item You have to upload all and only the {\bfseries{source files}} you wrote, with a {\bfseries{Makefile}} and a {\bfseries{readme.\+md}} where you describe how to compile, run your code, and a short report on what you have done, understood, and, eventually, benchmarked.
\item Your code must have no memory leaks.
\item No warnings must appear if compiled with the flags {\ttfamily -\/Wall -\/Wextra}.
\item Don\textquotesingle{}t change the name of the functions!
\item Once finished, send me either the link to the repository or a {\ttfamily tar.\+gz} with the files ({\ttfamily .git} folder included).
\end{DoxyItemize}\hypertarget{md_exam_instructions_autotoc_md1}{}\doxysection{Binary search tree}\label{md_exam_instructions_autotoc_md1}
The project consists of the implementation of a {\bfseries{template}} binary search tree (\mbox{\hyperlink{classBST}{B\+ST}}). A \mbox{\hyperlink{classBST}{B\+ST}} is a hierarchical (ordered) data structure where each {\bfseries{node}} can have at most two children, namely, {\bfseries{left}} and {\bfseries{right}} child. Each node stores a {\bfseries{pair}} of a {\bfseries{key}} and the associated {\bfseries{value}}. The binary tree is ordered according to the keys. If we assume that we sort the keys in ascending order (i.\+e., we use the less than {\ttfamily $<$} operator), then given a node {\ttfamily N}, all the nodes having keys {\bfseries{smaller}} than the key of the node {\ttfamily N} are on the {\bfseries{left}}. All the nodes with a key {\bfseries{greater}} than the key of the node {\ttfamily N} are on the {\bfseries{right}}.



Practically speaking, given the binary tree in the picture, if you need to insert a new node with {\ttfamily key=5}, you start from the root node {\ttfamily 8}, you go left since {\ttfamily 5$<$8}, you reach node {\ttfamily 3}, then you go right, you land in {\ttfamily 6}, you go left reaching node {\ttfamily 4}. Node {\ttfamily 4} has no right child, so the new node {\ttfamily 5} becomes the right child of node {\ttfamily 4}. If a key is already present in the tree, the associated value {\bfseries{is not}} changed.

From the implementation point of view, a node has two pointers {\ttfamily left} and {\ttfamily right} pointing to the left and right child, respectively. The pointers point to {\ttfamily nullptr} if they have no children.

It is useful to add a pointer (head, root, whatever you like) pointing to the top node, called {\bfseries{root node}}.\hypertarget{md_exam_instructions_autotoc_md2}{}\doxysubsection{Tree traversal}\label{md_exam_instructions_autotoc_md2}
The tree must be traversed in order, i.\+e., if I \char`\"{}print\char`\"{} the tree in the picture, I expect to see on the screen the sequence 
\begin{DoxyCode}{0}
\DoxyCodeLine{1 3 4 6 7 8 10 13 14}
\end{DoxyCode}


node {\ttfamily 1} is the first node, and node {\ttfamily 14} is the last one.\hypertarget{md_exam_instructions_autotoc_md3}{}\doxysubsection{Assignments}\label{md_exam_instructions_autotoc_md3}
You have to solve the following tasks using modern C++14 (C++17 is welcome as well).


\begin{DoxyItemize}
\item Implement a {\bfseries{template}} binary search tree class, named {\ttfamily bst}.
\item The class has three templates\+:
\begin{DoxyItemize}
\item the key type
\item the value type associated with the key
\item the type of the comparison operator, which is used to compare two keys. {\ttfamily std\+::less$<$key\+\_\+type$>$} should be used as default choice.
\end{DoxyItemize}
\item Implement proper iterators for your tree (i.\+e., {\ttfamily iterator} and {\ttfamily const\+\_\+iterator}). Forward iterator is sufficient.
\item Mark {\ttfamily noexcept} the right functions.
\item Remember the K\+I\+SS principle.
\item Implement at least the following public member functions.
\end{DoxyItemize}\hypertarget{md_exam_instructions_autotoc_md4}{}\doxyparagraph{Insert}\label{md_exam_instructions_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{std::pair<iterator, bool> insert(const pair\_type\& x);}
\DoxyCodeLine{std::pair<iterator, bool> insert(pair\_type\&\& x);}
\end{DoxyCode}


They are used to insert a new node. The function returns a pair of an iterator (pointing to the node) and a bool. The bool is true if a new node has been allocated, false otherwise (i.\+e., the key was already present in the tree). {\ttfamily pair\+\_\+type} can be for example {\ttfamily std\+::pair$<$const key\+\_\+type, value\+\_\+type$>$}.\hypertarget{md_exam_instructions_autotoc_md5}{}\doxyparagraph{Emplace}\label{md_exam_instructions_autotoc_md5}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{template< class... Types >}
\DoxyCodeLine{std::pair<iterator,bool> emplace(Types\&\&... args);}
\end{DoxyCode}


Inserts a new element into the container constructed in-\/place with the given args if there is no element with the key in the container.\hypertarget{md_exam_instructions_autotoc_md6}{}\doxyparagraph{Clear}\label{md_exam_instructions_autotoc_md6}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{void clear();}
\end{DoxyCode}


Clear the content of the tree.\hypertarget{md_exam_instructions_autotoc_md7}{}\doxyparagraph{Begin}\label{md_exam_instructions_autotoc_md7}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{iterator begin();}
\DoxyCodeLine{const\_iterator begin() const;}
\DoxyCodeLine{const\_iterator cbegin() const;}
\end{DoxyCode}


Return an iterator to the left-\/most node (which, likely, is not the root node).\hypertarget{md_exam_instructions_autotoc_md8}{}\doxyparagraph{End}\label{md_exam_instructions_autotoc_md8}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{iterator end();}
\DoxyCodeLine{const\_iterator end() const;}
\DoxyCodeLine{const\_iterator cend() const;}
\end{DoxyCode}


Return an iterator to one-\/past the last element.\hypertarget{md_exam_instructions_autotoc_md9}{}\doxyparagraph{Find}\label{md_exam_instructions_autotoc_md9}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{iterator find(const key\_type\& x);}
\DoxyCodeLine{const\_iterator find(const key\_type\& x) const;}
\end{DoxyCode}


Find a given key. If the key is present, returns an iterator to the proper node, {\ttfamily end()} otherwise.\hypertarget{md_exam_instructions_autotoc_md10}{}\doxyparagraph{Balance}\label{md_exam_instructions_autotoc_md10}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{void balance();}
\end{DoxyCode}


Balance the tree. A simple and naive implementation is fine. The aim of this exam is not producing a super-\/performant code, but learning c++. No extra points for complicated algorithms.\hypertarget{md_exam_instructions_autotoc_md11}{}\doxyparagraph{Subscripting operator}\label{md_exam_instructions_autotoc_md11}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{value\_type\& operator[](const key\_type\& x);}
\DoxyCodeLine{value\_type\& operator[](key\_type\&\& x);}
\end{DoxyCode}


Returns a reference to the value that is mapped to a key equivalent to {\ttfamily x}, performing an insertion if such key does not already exist.\hypertarget{md_exam_instructions_autotoc_md12}{}\doxyparagraph{Put-\/to operator}\label{md_exam_instructions_autotoc_md12}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{friend}
\DoxyCodeLine{std::ostream\& operator<<(std::ostream\& os, const bst\& x);}
\end{DoxyCode}


Implement the friend function {\bfseries{inside}} the class, such that you do not have to specify the templates for {\ttfamily bst}.\hypertarget{md_exam_instructions_autotoc_md13}{}\doxyparagraph{Copy and move}\label{md_exam_instructions_autotoc_md13}
The copy semantics perform a deep-\/copy. Move semantics is as usual.\hypertarget{md_exam_instructions_autotoc_md14}{}\doxyparagraph{Erase}\label{md_exam_instructions_autotoc_md14}

\begin{DoxyCode}{0}
\DoxyCodeLine{ \{c++\}}
\DoxyCodeLine{void erase(const key\_type\& x);}
\end{DoxyCode}


Removes the element (if one exists) with the key equivalent to key.\hypertarget{md_exam_instructions_autotoc_md15}{}\doxysubsection{Hints}\label{md_exam_instructions_autotoc_md15}

\begin{DoxyItemize}
\item {\bfseries{Big hint}} use {\ttfamily std\+::pair$<$const key\+\_\+type,value\+\_\+type$>$}, which is defined in the header {\ttfamily utility}
\item start coding and using the iterators A\+S\+AP. 
\end{DoxyItemize}