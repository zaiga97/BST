<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Advanced Programming Exam</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Advanced Programming Exam </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The exam consists of a written project followed by an oral discussion. The written project is due to February 16, 2020, at 8:55 AM. Orals take place on 16th and 17th of February.</p>
<ul>
<li>Work in groups made of two/three people.</li>
<li>Use a separate git repository.</li>
<li>You have to upload all and only the <b>source files</b> you wrote, with a <b>Makefile</b> and a <b>readme.md</b> where you describe how to compile, run your code, and a short report on what you have done, understood, and, eventually, benchmarked.</li>
<li>Your code must have no memory leaks.</li>
<li>No warnings must appear if compiled with the flags <code>-Wall -Wextra</code>.</li>
<li>Don't change the name of the functions!</li>
<li>Once finished, send me either the link to the repository or a <code>tar.gz</code> with the files (<code>.git</code> folder included).</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Binary search tree</h1>
<p>The project consists of the implementation of a <b>template</b> binary search tree (<a class="el" href="classBST.html">BST</a>). A <a class="el" href="classBST.html">BST</a> is a hierarchical (ordered) data structure where each <b>node</b> can have at most two children, namely, <b>left</b> and <b>right</b> child. Each node stores a <b>pair</b> of a <b>key</b> and the associated <b>value</b>. The binary tree is ordered according to the keys. If we assume that we sort the keys in ascending order (i.e., we use the less than <code>&lt;</code> operator), then given a node <code>N</code>, all the nodes having keys <b>smaller</b> than the key of the node <code>N</code> are on the <b>left</b>. All the nodes with a key <b>greater</b> than the key of the node <code>N</code> are on the <b>right</b>.</p>
<p><img src="./.aux/binary.png" alt="" class="inline"/></p>
<p>Practically speaking, given the binary tree in the picture, if you need to insert a new node with <code>key=5</code>, you start from the root node <code>8</code>, you go left since <code>5&lt;8</code>, you reach node <code>3</code>, then you go right, you land in <code>6</code>, you go left reaching node <code>4</code>. Node <code>4</code> has no right child, so the new node <code>5</code> becomes the right child of node <code>4</code>. If a key is already present in the tree, the associated value <b>is not</b> changed.</p>
<p>From the implementation point of view, a node has two pointers <code>left</code> and <code>right</code> pointing to the left and right child, respectively. The pointers point to <code>nullptr</code> if they have no children.</p>
<p>It is useful to add a pointer (head, root, whatever you like) pointing to the top node, called <b>root node</b>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Tree traversal</h2>
<p>The tree must be traversed in order, i.e., if I "print" the tree in the picture, I expect to see on the screen the sequence </p><div class="fragment"><div class="line">1 3 4 6 7 8 10 13 14</div>
</div><!-- fragment --><p>node <code>1</code> is the first node, and node <code>14</code> is the last one.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Assignments</h2>
<p>You have to solve the following tasks using modern C++14 (C++17 is welcome as well).</p>
<ul>
<li>Implement a <b>template</b> binary search tree class, named <code>bst</code>.</li>
<li>The class has three templates:<ul>
<li>the key type</li>
<li>the value type associated with the key</li>
<li>the type of the comparison operator, which is used to compare two keys. <code>std::less&lt;key_type&gt;</code> should be used as default choice.</li>
</ul>
</li>
<li>Implement proper iterators for your tree (i.e., <code>iterator</code> and <code>const_iterator</code>). Forward iterator is sufficient.</li>
<li>Mark <code>noexcept</code> the right functions.</li>
<li>Remember the KISS principle.</li>
<li>Implement at least the following public member functions.</li>
</ul>
<h4><a class="anchor" id="autotoc_md4"></a>
Insert</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::pair&lt;iterator, bool&gt; insert(const pair_type&amp; x);</div>
<div class="line">std::pair&lt;iterator, bool&gt; insert(pair_type&amp;&amp; x);</div>
</div><!-- fragment --><p>They are used to insert a new node. The function returns a pair of an iterator (pointing to the node) and a bool. The bool is true if a new node has been allocated, false otherwise (i.e., the key was already present in the tree). <code>pair_type</code> can be for example <code>std::pair&lt;const key_type, value_type&gt;</code>.</p>
<h4><a class="anchor" id="autotoc_md5"></a>
Emplace</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">template&lt; class... Types &gt;</div>
<div class="line">std::pair&lt;iterator,bool&gt; emplace(Types&amp;&amp;... args);</div>
</div><!-- fragment --><p>Inserts a new element into the container constructed in-place with the given args if there is no element with the key in the container.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
Clear</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void clear();</div>
</div><!-- fragment --><p>Clear the content of the tree.</p>
<h4><a class="anchor" id="autotoc_md7"></a>
Begin</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">iterator begin();</div>
<div class="line">const_iterator begin() const;</div>
<div class="line">const_iterator cbegin() const;</div>
</div><!-- fragment --><p>Return an iterator to the left-most node (which, likely, is not the root node).</p>
<h4><a class="anchor" id="autotoc_md8"></a>
End</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">iterator end();</div>
<div class="line">const_iterator end() const;</div>
<div class="line">const_iterator cend() const;</div>
</div><!-- fragment --><p>Return an iterator to one-past the last element.</p>
<h4><a class="anchor" id="autotoc_md9"></a>
Find</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">iterator find(const key_type&amp; x);</div>
<div class="line">const_iterator find(const key_type&amp; x) const;</div>
</div><!-- fragment --><p>Find a given key. If the key is present, returns an iterator to the proper node, <code>end()</code> otherwise.</p>
<h4><a class="anchor" id="autotoc_md10"></a>
Balance</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void balance();</div>
</div><!-- fragment --><p>Balance the tree. A simple and naive implementation is fine. The aim of this exam is not producing a super-performant code, but learning c++. No extra points for complicated algorithms.</p>
<h4><a class="anchor" id="autotoc_md11"></a>
Subscripting operator</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">value_type&amp; operator[](const key_type&amp; x);</div>
<div class="line">value_type&amp; operator[](key_type&amp;&amp; x);</div>
</div><!-- fragment --><p>Returns a reference to the value that is mapped to a key equivalent to <code>x</code>, performing an insertion if such key does not already exist.</p>
<h4><a class="anchor" id="autotoc_md12"></a>
Put-to operator</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">friend</div>
<div class="line">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const bst&amp; x);</div>
</div><!-- fragment --><p>Implement the friend function <b>inside</b> the class, such that you do not have to specify the templates for <code>bst</code>.</p>
<h4><a class="anchor" id="autotoc_md13"></a>
Copy and move</h4>
<p>The copy semantics perform a deep-copy. Move semantics is as usual.</p>
<h4><a class="anchor" id="autotoc_md14"></a>
Erase</h4>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void erase(const key_type&amp; x);</div>
</div><!-- fragment --><p>Removes the element (if one exists) with the key equivalent to key.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Hints</h2>
<ul>
<li><b>Big hint</b> use <code>std::pair&lt;const key_type,value_type&gt;</code>, which is defined in the header <code>utility</code></li>
<li>start coding and using the iterators ASAP. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
